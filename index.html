<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Formula One History</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: Georgia, serif;
            background-color: #F9F9F7;
            color: #111;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            width: 600px;
            max-width: 100%;
            padding: 20px;
        }

        h1 {
            font-family: 'Cheltenham', 'Times New Roman', Times, serif; /* Cheltenham fallback */
            font-size: 3em;
            color: #1C4E80; /* Primary color */
            text-align: center;
            margin-bottom: 0.2em;
        }

        .deck {
            font-family: 'Franklin', 'Arial Narrow', Arial, sans-serif; /* Franklin fallback */
            font-size: 1.2em;
            color: #777; /* Grayscale */
            text-align: center;
            margin-bottom: 2em;
        }

        .step {
            margin-bottom: 100vh; /* Ensure enough space for scrolling */
            padding: 20px;
            border-radius: 5px;
            background-color: rgba(255, 255, 255, 0.8);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .step.active {
            background-color: rgba(220, 220, 240, 0.9); /* Subtle highlight for active step */
        }

        .chart-container {
            width: 100%;
            height: 400px; /* Default height, can be adjusted per chart */
            margin-bottom: 2em;
            position: sticky;
            top: 100px; /* Adjust as needed */
            z-index: -1; /* Keep charts behind text */
        }

        svg {
            width: 100%;
            height: 100%;
            display: block;
            background-color: #F9F9F7; /* Match body background */
        }

        .axis path,
        .axis line {
            fill: none;
            stroke: #777; /* Grayscale for axes */
            stroke-width: 1px;
            shape-rendering: crispEdges;
        }

        .axis text {
            font-family: 'Franklin', 'Arial Narrow', Arial, sans-serif;
            font-size: 0.8em;
            fill: #777;
        }

        .grid line {
            stroke: #111; /* Grid color */
            stroke-opacity: 0.15; /* Hairline grid opacity */
            shape-rendering: crispEdges;
        }

        .chart-title {
            font-family: 'Franklin', 'Arial Narrow', Arial, sans-serif;
            font-size: 1.1em;
            fill: #111;
            text-anchor: middle;
        }

        /* Chart-specific styles will be added later */
        .line-champion-age {
            fill: none;
            stroke: #1C4E80; /* Primary color */
            stroke-width: 2px;
        }

        .regression-line {
            fill: none;
            stroke: #D55E00; /* Secondary color */
            stroke-width: 1.5px;
            stroke-dasharray: 4, 4;
        }

        .bar-constructor {
            /* fill will be set dynamically */
            stroke: #111;
            stroke-width: 0.5px;
        }

        .area-nationality {
            /* fill will be set dynamically */
            stroke-width: 0.5px;
            stroke: #111;
        }
        .highlight {
            /* Define highlight style, e.g., increased stroke-width or opacity */
        }

    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Formula One: A Visual History</h1>
            <p class="deck">Exploring decades of speed, strategy, and skill through data.</p>
        </header>

        <div id="scrolly">
            <div class="chart-container" id="chart-container-1">
                <svg id="chart1" role="img" aria-labelledby="chart1-title">
                    <title id="chart1-title">Average Age of Formula One Champions Over Time</title>
                    <!-- Chart 1 will be rendered here -->
                </svg>
            </div>
            <div class="step" data-chart="1" data-step-id="championAgeIntro">
                <h2>The Evolving Champion</h2>
                <p>Formula One has seen champions of all ages. This chart tracks the average age of the World Champion each year, revealing trends in when drivers typically reach their peak.</p>
            </div>
            <div class="step" data-chart="1" data-step-id="championAgeRegression">
                <p>A regression line helps visualize the overall trend. Has the average age of champions been increasing, decreasing, or staying relatively stable over the decades?</p>
            </div>

            <div class="chart-container" id="chart-container-2">
                <svg id="chart2" role="img" aria-labelledby="chart2-title">
                    <title id="chart2-title">Constructor Title Streaks in Formula One</title>
                    <!-- Chart 2 will be rendered here -->
                </svg>
            </div>
            <div class="step" data-chart="2" data-step-id="constructorStreaksIntro">
                <h2>Eras of Dominance</h2>
                <p>Certain constructors have defined eras in Formula One with extended periods of championship success. This timeline highlights the longest title streaks.</p>
            </div>
             <div class="step" data-chart="2" data-step-id="constructorHighlight">
                <p>Notice how some teams managed to maintain their competitive edge for multiple consecutive years, shaping the sport's history.</p>
            </div>


            <div class="chart-container" id="chart-container-3">
                <svg id="chart3" role="img" aria-labelledby="chart3-title">
                    <title id="chart3-title">Driver Nationality Wins Per Decade</title>
                    <!-- Chart 3 will be rendered here -->
                </svg>
            </div>
            <div class="step" data-chart="3" data-step-id="nationalityWinsIntro">
                <h2>Global Talent Pool</h2>
                <p>Formula One attracts drivers from around the world. This chart explores the distribution of wins by driver nationality across different decades, showcasing which nations have historically produced the most successful drivers.</p>
            </div>
            <div class="step" data-chart="3" data-step-id="nationalityFocus">
                <p>Observe how the prominence of certain nationalities has shifted over time, reflecting the global growth and changing dynamics of the sport.</p>
            </div>
        </div>

        <footer>
            <p style="text-align:center; font-size:0.8em; color:#777;">Data sources: championAge.csv, constructorStreaks.csv, nationalityWins.csv (pre-filtered historical summaries). Visualisation by Jules.</p>
        </footer>
    </div>

    <script>
        // CSV Data will be embedded here in the next step
        const championAgeCsvData = `year,avgChampionAge
1950,40
1951,40
1952,36
1953,36
1954,40
1955,38
1956,44
1957,46
1958,24
1959,33
1960,34
1961,29
1962,36
1963,27
1964,30
1965,29
1966,30
1967,32
1968,42
1969,30
1970,28
1971,32
1972,25
1973,34
1974,27
1975,28
1976,27
1977,28
1978,28
1979,29
1980,28
1981,29
1982,30
1983,31
1984,33
1985,30
1986,31
1987,30
1988,30
1989,34
1990,31
1991,31
1992,39
1993,38
1994,25
1995,26
1996,27
1997,28
1998,30
1999,31
2000,31
2001,32
2002,33
2003,34
2004,35
2005,24
2006,25
2007,27
2008,23
2009,29
2010,23
2011,24
2012,25
2013,26
2014,29
2015,30
2016,31
2017,32
2018,33
2019,34
2020,35
2021,24
2022,25
2023,26`;

        const constructorStreaksCsvData = `team,startYear,endYear,length
Ferrari,1952,1953,2
Mercedes,1954,1955,2
Cooper,1959,1960,2
Ferrari,1961,1961,1
BRM,1962,1962,1
Lotus,1963,1963,1
Ferrari,1964,1964,1
Lotus,1965,1965,1
Brabham,1966,1967,2
Lotus,1968,1968,1
Matra,1969,1969,1
Lotus,1970,1970,1
Tyrrell,1971,1971,1
Lotus,1972,1973,2
McLaren,1974,1974,1
Ferrari,1975,1977,3
Lotus,1978,1978,1
Ferrari,1979,1979,1
Williams,1980,1981,2
Ferrari,1982,1983,2
McLaren,1984,1985,2
Williams,1986,1987,2
McLaren,1988,1991,4
Williams,1992,1994,3
Benetton,1995,1995,1
Williams,1996,1997,2
McLaren,1998,1998,1
Ferrari,1999,2004,6
Renault,2005,2006,2
Ferrari,2007,2008,2
Brawn GP,2009,2009,1
Red Bull,2010,2013,4
Mercedes,2014,2021,8
Red Bull,2022,2023,2`;

        const nationalityWinsCsvData = `decade,nationality,wins
1950,Argentine,18
1950,Italian,14
1950,American,3
1950,British,1
1960,British,61
1960,American,10
1960,New Zealander,10
1960,Australian,9
1960,German,2
1970,British,42
1970,Brazilian,14
1970,Austrian,13
1970,Argentine,9
1970,Swedish,9
1980,Brazilian,35
1980,French,27
1980,Finnish,10
1980,Australian,7
1980,Austrian,7
1990,British,34
1990,German,29
1990,Brazilian,21
1990,French,10
1990,Canadian,1
2000,German,57
2000,Brazilian,20
2000,Finnish,19
2000,Spanish,16
2000,British,11
2010,German,66
2010,British,56
2010,Australian,11
2010,Finnish,10
2010,Spanish,8
2020,Dutch,49
2020,British,20
2020,Mexican,4
2020,French,3
2020,Finnish,2`;

        // D3 code for charts and interactions will go here

        // --- Data Loading and Preprocessing ---

        function parseAndCleanData() {
            // --- Champion Age Data ---
            let championAgeData = d3.csvParse(championAgeCsvData, d => ({
                year: +d.year,
                avgChampionAge: +d.avgChampionAge
            }));

            // Outlier removal for championAgeData.avgChampionAge
            championAgeData = removeOutliers(championAgeData, 'avgChampionAge');

            // --- Constructor Streaks Data ---
            let constructorStreaksData = d3.csvParse(constructorStreaksCsvData, d => ({
                team: d.team,
                startYear: +d.startYear,
                endYear: +d.endYear,
                length: +d.length
            }));
            // No numeric series specified for outlier removal in spec for streaks, length is derived.
            // Assuming 'length' might be a candidate if it were independent.
            // constructorStreaksData = removeOutliers(constructorStreaksData, 'length');


            // --- Nationality Wins Data ---
            let nationalityWinsData = d3.csvParse(nationalityWinsCsvData, d => ({
                decade: +d.decade,
                nationality: d.nationality,
                wins: +d.wins
            }));

            // Outlier removal for nationalityWinsData.wins
            nationalityWinsData = removeOutliers(nationalityWinsData, 'wins');

            // Identify top 5 nationalities overall to filter for the chart
            const totalWinsByNationality = d3.rollup(nationalityWinsData, v => d3.sum(v, d => d.wins), d => d.nationality);
            const top5Nationalities = Array.from(totalWinsByNationality.entries())
                                          .sort((a, b) => b[1] - a[1])
                                          .slice(0, 5)
                                          .map(d => d[0]);

            const filteredNationalityWinsData = nationalityWinsData.filter(d => top5Nationalities.includes(d.nationality));


            return { championAgeData, constructorStreaksData, filteredNationalityWinsData, top5Nationalities };
        }

        function removeOutliers(data, columnName) {
            if (!data || data.length === 0) return [];
            const values = data.map(d => d[columnName]).sort(d3.ascending);
            const q1 = d3.quantile(values, 0.25);
            const q3 = d3.quantile(values, 0.75);
            const iqr = q3 - q1;
            const lowerBound = q1 - 1.5 * iqr;
            const upperBound = q3 + 1.5 * iqr;

            return data.filter(d => d[columnName] >= lowerBound && d[columnName] <= upperBound);
        }

        let processedData; // To store the results of parseAndCleanData

        document.addEventListener('DOMContentLoaded', () => {
            processedData = parseAndCleanData();
            console.log("Processed Data:", processedData);

            initChampionAgeChart(); // Initialize chart 1
            initConstructorStreaksChart(); // Initialize chart 2
            initNationalityWinsChart(); // Initialize chart 3

            initScrollytelling(); // Initialize Intersection Observer interactions

            // Final size check
            console.log('Size KB:',(new Blob([document.documentElement.outerHTML]).size/1024).toFixed(1));
        });

        // --- Chart 1: Champion Age ---
        function initChampionAgeChart() {
            const data = processedData.championAgeData;
            if (!data || data.length === 0) {
                console.warn("Champion age data is empty or undefined. Skipping chart rendering.");
                return;
            }

            const svg = d3.select("#chart1");
            const margin = {top: 40, right: 30, bottom: 50, left: 50};
            const width = 600 - margin.left - margin.right;
            const height = 400 - margin.top - margin.bottom;

            const chartG = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Add chart title
            svg.append("text")
                .attr("class", "chart-title")
                .attr("x", (width + margin.left + margin.right) / 2)
                .attr("y", margin.top / 2 + 5)
                .attr("text-anchor", "middle")
                .text("Average Age of F1 Champions (1950-2023)");

            // Scales
            const x = d3.scaleLinear()
                .domain(d3.extent(data, d => d.year))
                .range([0, width]);

            const y = d3.scaleLinear()
                .domain([0, d3.max(data, d => d.avgChampionAge) * 1.1]) // Add some padding to max age
                .range([height, 0]);

            // Axes
            const xAxis = d3.axisBottom(x).tickFormat(d3.format("d")).ticks(10);
            const yAxis = d3.axisLeft(y);

            chartG.append("g")
                .attr("class", "axis x-axis")
                .attr("transform", `translate(0,${height})`)
                .call(xAxis);

            chartG.append("g")
                .attr("class", "axis y-axis")
                .call(yAxis);

            // Gridlines
            chartG.append("g")
                .attr("class", "grid")
                .call(d3.axisLeft(y)
                    .ticks(5)
                    .tickSize(-width)
                    .tickFormat("")
                );

            // Line generator
            const line = d3.line()
                .x(d => x(d.year))
                .y(d => y(d.avgChampionAge));

            // Draw the line
            chartG.append("path")
                .datum(data)
                .attr("class", "line-champion-age data-line") // Added data-line class for potential highlighting
                .attr("d", line)
                .attr("aria-label", "Line showing average champion age per year");


            // Regression Line Calculation
            const xMean = d3.mean(data, d => d.year);
            const yMean = d3.mean(data, d => d.avgChampionAge);
            const numerator = d3.sum(data, d => (d.year - xMean) * (d.avgChampionAge - yMean));
            const denominator = d3.sum(data, d => Math.pow(d.year - xMean, 2));
            const slope = numerator / denominator;
            const intercept = yMean - slope * xMean;

            const regressionPoints = data.map(d => ({
                year: d.year,
                avgChampionAge: slope * d.year + intercept
            }));

            // Draw the regression line
            chartG.append("path")
                .datum(regressionPoints)
                .attr("class", "regression-line")
                .attr("d", line) // Re-use the line generator with new data
                .attr("aria-label", "Regression line showing trend of average champion age");

            // Annotation example (can be expanded based on scrollytelling interaction)
            // For now, let's highlight the youngest and oldest average ages
            const youngest = data.reduce((min, p) => p.avgChampionAge < min.avgChampionAge ? p : min, data[0]);
            const oldest = data.reduce((max, p) => p.avgChampionAge > max.avgChampionAge ? p : max, data[0]);

            const annotations = [
                { year: youngest.year, age: youngest.avgChampionAge, label: `Youngest Avg: ${youngest.avgChampionAge} (${youngest.year})` },
                { year: oldest.year, age: oldest.avgChampionAge, label: `Oldest Avg: ${oldest.avgChampionAge} (${oldest.year})` }
            ];

            const annotationGroup = chartG.append("g").attr("class", "annotations");

            annotations.forEach(ann => {
                const annX = x(ann.year);
                const annY = y(ann.age);

                annotationGroup.append("circle")
                    .attr("cx", annX)
                    .attr("cy", annY)
                    .attr("r", 4)
                    .attr("fill", "#0072B2");

                annotationGroup.append("text")
                    .attr("x", annX + 5)
                    .attr("y", annY - 5)
                    .text(ann.label)
                    .attr("font-size", "0.7em")
                    .attr("fill", "#0072B2");
            });

            // Store elements for scrollytelling updates
            svg.node()._chartUpdate = (stepId) => {
                chartG.selectAll(".data-line").classed("highlight", stepId === "championAgeIntro" || stepId === "championAgeRegression");
                chartG.selectAll(".regression-line").style("opacity", stepId === "championAgeRegression" ? 1 : 0.3);
                annotationGroup.style("opacity", (stepId === "championAgeIntro" || stepId === "championAgeRegression") ? 1 : 0.3);
            };
        }

        // --- Chart 2: Constructor Streaks ---
        function initConstructorStreaksChart() {
            const data = processedData.constructorStreaksData;
            if (!data || data.length === 0) {
                console.warn("Constructor streaks data is empty or undefined. Skipping chart rendering.");
                return;
            }
            // Sort data by start year for timeline consistency
            data.sort((a, b) => a.startYear - b.startYear || a.length - b.length);


            const svg = d3.select("#chart2");
            const margin = {top: 40, right: 30, bottom: 50, left: 100}; // Increased left margin for team names
            const width = 600 - margin.left - margin.right;
            const height = 400 - margin.top - margin.bottom;

            const chartG = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            svg.append("text")
                .attr("class", "chart-title")
                .attr("x", (width + margin.left + margin.right) / 2)
                .attr("y", margin.top / 2 + 5)
                .attr("text-anchor", "middle")
                .text("Constructor Championship Streaks (Min 1 Year)");

            // Scales
            const y = d3.scaleBand()
                .domain(data.map(d => d.team + "_" + d.startYear)) // Unique key for each streak
                .range([0, height])
                .padding(0.2);

            const x = d3.scaleLinear()
                .domain([d3.min(data, d => d.startYear) -1 , d3.max(data, d => d.endYear) + 1])
                .range([0, width]);

            const colorPalette = ["#1C4E80", "#D55E00", "#0072B2", "#E69F00", "#A0A0A0", "#505050"];
            const teamColors = {};
            let colorIndex = 0;
            data.forEach(d => {
                if (!teamColors[d.team]) {
                    teamColors[d.team] = colorPalette[colorIndex % colorPalette.length];
                    colorIndex++;
                }
            });

            // Axes
            const xAxis = d3.axisBottom(x).tickFormat(d3.format("d")).ticks(Math.min(10, (x.domain()[1]-x.domain()[0])));
            const yAxis = d3.axisLeft(y)
                .tickFormat(val => {
                    const [team, year] = val.split("_");
                    return team; // Only show team name, avoid clutter
                })
                .tickSize(0) // No ticks, direct labels
                .tickPadding(10);


            chartG.append("g")
                .attr("class", "axis x-axis")
                .attr("transform", `translate(0,${height})`)
                .call(xAxis);

            const yAxisGroup = chartG.append("g")
                .attr("class", "axis y-axis")
                .call(yAxis);

            // Remove domain line from y-axis for cleaner look
            yAxisGroup.select(".domain").remove();
            yAxisGroup.selectAll(".tick text")
                .attr("fill", d => {
                     const team = d.split("_")[0];
                     return teamColors[team] || "#111";
                });


            // Gridlines for X-axis
            chartG.append("g")
                .attr("class", "grid")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(x)
                    .ticks(Math.min(10, (x.domain()[1]-x.domain()[0])))
                    .tickSize(-height)
                    .tickFormat("")
                );

            // Bars
            const bars = chartG.selectAll(".bar-constructor")
                .data(data)
                .enter()
                .append("rect")
                .attr("class", d => `bar-constructor team-${d.team.replace(/\s+/g, '-').toLowerCase()}`)
                .attr("y", d => y(d.team + "_" + d.startYear))
                .attr("x", d => x(d.startYear))
                .attr("width", d => x(d.endYear + 1) - x(d.startYear)) // +1 to include end year fully
                .attr("height", y.bandwidth())
                .attr("fill", d => teamColors[d.team] || "#777")
                .attr("aria-label", d => `${d.team} championship streak from ${d.startYear} to ${d.endYear}, ${d.length} years.`);

            // Direct labels on bars (streak length)
            chartG.selectAll(".bar-label")
                .data(data)
                .enter()
                .append("text")
                .attr("class", "bar-label")
                .attr("x", d => x(d.startYear) + (x(d.endYear + 1) - x(d.startYear)) / 2)
                .attr("y", d => y(d.team + "_" + d.startYear) + y.bandwidth() / 2)
                .attr("dy", "0.35em")
                .attr("text-anchor", "middle")
                .text(d => d.length)
                .attr("fill", "#FFF") // White text for contrast on dark bars
                .style("font-size", "0.7em")
                .style("pointer-events", "none"); // So text doesn't interfere with bar events

            // Store elements for scrollytelling updates
            svg.node()._chartUpdate = (stepId) => {
                const highlightTeam = stepId === "constructorHighlight" ? "Mercedes" : null; // Example, could be dynamic

                bars.transition().duration(300)
                    .attr("opacity", d => {
                        if (!highlightTeam) return 1;
                        return d.team === highlightTeam ? 1 : 0.3;
                    });
                 yAxisGroup.selectAll(".tick text")
                    .transition().duration(300)
                    .attr("opacity", d => {
                         if (!highlightTeam) return 1;
                         const team = d.split("_")[0];
                         return team === highlightTeam ? 1 : 0.3;
                    });
            };
        }

        // --- Chart 3: Nationality Wins (Stacked Area) ---
        function initNationalityWinsChart() {
            const rawData = processedData.filteredNationalityWinsData;
            const topNationalities = processedData.top5Nationalities;

            if (!rawData || rawData.length === 0 || !topNationalities || topNationalities.length === 0) {
                console.warn("Nationality wins data or top nationalities are empty. Skipping chart rendering.");
                return;
            }

            // Transform data for stacking: group by decade, then sum wins for each of the top 5 nationalities
            const decades = Array.from(new Set(rawData.map(d => d.decade))).sort(d3.ascending);
            const dataForStacking = decades.map(decade => {
                const entry = { decade: decade };
                topNationalities.forEach(nat => {
                    const record = rawData.find(r => r.decade === decade && r.nationality === nat);
                    entry[nat] = record ? record.wins : 0;
                });
                return entry;
            });

            const stack = d3.stack().keys(topNationalities);
            const series = stack(dataForStacking);

            const svg = d3.select("#chart3");
            const margin = {top: 40, right: 30, bottom: 50, left: 50};
            const width = 600 - margin.left - margin.right;
            const height = 400 - margin.top - margin.bottom;

            const chartG = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            svg.append("text")
                .attr("class", "chart-title")
                .attr("x", (width + margin.left + margin.right) / 2)
                .attr("y", margin.top / 2 + 5)
                .attr("text-anchor", "middle")
                .text("Wins by Top 5 Nationalities per Decade");

            // Scales
            const x = d3.scalePoint() // Using scalePoint for discrete decades
                .domain(decades)
                .range([0, width])
                .padding(0.5);

            const y = d3.scaleLinear()
                .domain([0, d3.max(series, s => d3.max(s, d => d[1]))]) // Max of the stacked values
                .range([height, 0]);

            const colorPalette = ["#1C4E80", "#D55E00", "#0072B2", "#E69F00", "#785EF0"]; // Adjusted palette
            const color = d3.scaleOrdinal()
                .domain(topNationalities)
                .range(colorPalette);

            // Axes
            const xAxis = d3.axisBottom(x).tickFormat(d => d + "s"); // e.g., 1950s
            const yAxis = d3.axisLeft(y);

            chartG.append("g")
                .attr("class", "axis x-axis")
                .attr("transform", `translate(0,${height})`)
                .call(xAxis);

            chartG.append("g")
                .attr("class", "axis y-axis")
                .call(yAxis);

            // Gridlines for Y-axis
             chartG.append("g")
                .attr("class", "grid")
                .call(d3.axisLeft(y)
                    .ticks(5)
                    .tickSize(-width)
                    .tickFormat("")
                );

            // Area generator
            const area = d3.area()
                .x(d => x(d.data.decade))
                .y0(d => y(d[0]))
                .y1(d => y(d[1]));

            // Draw areas
            const areas = chartG.selectAll(".area-nationality")
                .data(series)
                .enter().append("path")
                .attr("class", d => `area-nationality nationality-${d.key.replace(/\s+/g, '-').toLowerCase()}`)
                .attr("d", area)
                .style("fill", d => color(d.key))
                .attr("aria-label", d => `Area showing wins for ${d.key} drivers per decade.`);

            // Legend
            const legend = chartG.append("g")
                .attr("class", "legend")
                .attr("transform", `translate(${width - 100}, 0)`); // Position legend

            topNationalities.forEach((nationality, i) => {
                const legendRow = legend.append("g")
                    .attr("transform", `translate(0, ${i * 20})`);

                legendRow.append("rect")
                    .attr("width", 10)
                    .attr("height", 10)
                    .attr("fill", color(nationality));

                legendRow.append("text")
                    .attr("x", 15)
                    .attr("y", 10)
                    .text(nationality)
                    .style("font-size", "0.7em")
                    .attr("alignment-baseline", "middle");
            });

            // Store elements for scrollytelling updates
            svg.node()._chartUpdate = (stepId) => {
                const highlightNationality = stepId === "nationalityFocus" ? topNationalities[0] : null; // Example: highlight first nationality

                areas.transition().duration(300)
                    .style("opacity", d => {
                        if (!highlightNationality) return 1;
                        return d.key === highlightNationality ? 1 : 0.3;
                    });

                legend.selectAll("g")
                    .transition().duration(300)
                    .style("opacity", d => { // d is undefined here, need to select text/rect to get data
                         const textNode = d3.select(this).select("text"); // 'this' context issue
                         if (textNode.empty()) return 0.3; // Should not happen if selection is correct
                         const nationality = textNode.text();
                         if (!highlightNationality) return 1;
                         return nationality === highlightNationality ? 1 : 0.3;
                    });
                 // Corrected legend highlighting:
                legend.selectAll("g").each(function(legendData, i) { // Use .each to get current data context
                    const nationality = topNationalities[i]; // Assuming legend items are in the same order
                    d3.select(this).transition().duration(300)
                        .style("opacity", () => {
                            if (!highlightNationality) return 1;
                            return nationality === highlightNationality ? 1 : 0.3;
                        });
                });
            };
        }

        // --- Scrollytelling Interaction ---
        function initScrollytelling() {
            const steps = d3.selectAll(".step");
            // Ensure charts are "visible" initially or tied to the first step.
            // This logic depends on how charts are initially displayed vs. activated by scroll.
            // For this setup, charts are always in DOM, their content updates.

            const observer = new IntersectionObserver(entries => {
                entries.forEach(entry => {
                    const stepElement = entry.target;
                    const stepId = stepElement.dataset.stepId;
                    const chartNumber = stepElement.dataset.chart;
                    const chartSvg = d3.select(`#chart${chartNumber}`).node();

                    if (entry.isIntersecting) {
                        // Add active class to current step
                        steps.classed("active", false); // Remove from all
                        d3.select(stepElement).classed("active", true);

                        // Update the corresponding chart
                        if (chartSvg && typeof chartSvg._chartUpdate === 'function') {
                            chartSvg._chartUpdate(stepId);
                        }

                        // Make current chart container visible, hide others (optional, if charts are absolutely positioned)
                        // d3.selectAll(".chart-container").style("display", "none");
                        // d3.select(`#chart-container-${chartNumber}`).style("display", "block");


                    } else {
                        // Optional: remove active class when scrolling out of view if another step isn't immediately active
                        // d3.select(stepElement).classed("active", false);
                    }
                });
            }, { threshold: 0.5, rootMargin: "-10% 0px -50% 0px" }); // Adjust threshold and rootMargin as needed

            steps.each(function() {
                observer.observe(this);
            });

            // Trigger update for the first step of the first chart manually if needed on load
            // This ensures the first chart state is correctly set before any scrolling.
             const firstStepOfChart1 = d3.select('.step[data-chart="1"]');
             if (!firstStepOfChart1.empty()) {
                 const firstStepId = firstStepOfChart1.attr('data-step-id');
                 const chart1Svg = d3.select("#chart1").node();
                 if (chart1Svg && typeof chart1Svg._chartUpdate === 'function') {
                     // chart1Svg._chartUpdate(firstStepId); // Initial state, can be too aggressive
                 }
             }
        }
    </script>
</body>
</html>
